// *********************************************************
//
// File autogenerated for the ${pkgname} package
// by the rosparam_handler package.
// Please do not edit.
//
// ********************************************************/

#ifndef _${pkgname}_ROSPARAM_HANDLER_${ClassName}Parameters_H_
#define _${pkgname}_ROSPARAM_HANDLER_${ClassName}Parameters_H_

#include <rosparam_handler/ParametersBase.h>

#ifdef DYNAMIC_RECONFIGURE_FOUND
#include <${pkgname}/${ClassName}Config.h>
#else
struct ${ClassName}Config{};
#endif

namespace ${pkgname} {

/// \brief Parameter struct generated by rosparam_handler
struct ${ClassName}Parameters : public rosparam_handler::ParametersBase {

  using Config = ${ClassName}Config;
  using Ptr = boost::shared_ptr<${ClassName}Parameters>;
  using ConstPtr = boost::shared_ptr<const ${ClassName}Parameters>;

  inline ${ClassName}Parameters(const ros::NodeHandle& private_node_handle) :
    rosparam_handler::ParametersBase(private_node_handle) {}

  inline ${ClassName}Parameters(const ${ClassName}Parameters& o)
  : ParametersBase(o)
  $copyConstructor

  {
    //
  }

  ${ClassName}Parameters& operator=(const ${ClassName}Parameters& o)
  {
    rosparam_handler::ParametersBase::operator=(o);
    $assignOperator
    return *this;
  }

  /// \brief Set parameters on ROS parameter server.
  void toParamServer() override {
$toParamServer
  }

  /// \brief the parameters members.

  $parameters

protected:

    /// \brief Get values from parameter server
    ///
    /// Will fail if a value can not be found and no default value is given.
    inline bool fromParamServerImpl() override {

      bool success = true;

  $fromParamServer
  $test_limits

      return success;

    }

    /// \brief print. A helper function to be called from base stream operator for printing parameter struct
    inline std::ostream& print(std::ostream& os) const override
    {
      os << "[" << nodeName << "]\nNode " << nodeName << " has the following parameters:\n"
  $string_representation;
      return os;
    }

  /// \brief Issue a warning about missing default parameters.
  inline void missingParamsWarning() override {
    ROS_WARN_STREAM("[" << nodeName << "]\nThe following parameters do not have default values and need to be specified:\n"
$non_default_params    );
  }

};

using ${ClassName}ParametersPtr = ${ClassName}Parameters::Ptr;
using ${ClassName}ParametersConstPtr = ${ClassName}Parameters::ConstPtr;

} // namespace ${pkgname}

#ifdef DYNAMIC_RECONFIGURE_FOUND
namespace rosparam_handler
{

  /// \brief Specialize base class fromConfigImpl.
  /// to handle ${pkgname}::${ClassName}Config

  template<>
  inline void ParametersBase::fromConfigImpl<${pkgname}::${ClassName}Config>(
    const ${pkgname}::${ClassName}Config& config, const uint32_t /*level*/ )
  {
    try {
		  ${pkgname}::${ClassName}Parameters& casted_ref = dynamic_cast<${pkgname}::${ClassName}Parameters&>(*this);

      $fromConfig
	  }
	  catch (const std::bad_cast& /*e*/)
	  {
		  ROS_FATAL("In ParametersBase::fromConfig, bad cast to type ${pkgname}::${ClassName}Parameters !");
		  rosparam_handler::exit("In ParametersBase::fromConfig, bad cast to type ${pkgname}::${ClassName}Parameters !");
	  }
  }

}
#endif

#endif /* _${pkgname}_ROSPARAM_HANDLER_${ClassName}Parameters_H_ */
